
use super::{BLOG_URL, COMRAK_OPTIONS, BASE, DEFAULT_PAGE_TEMPLATE, DEFAULT_PAGE_DROPDOWN, DEFAULT_PAGE_MENU, PAGE_TEMPLATES, STATIC_PAGES_DIR};
use accept::*;
use blog::GenTimer;
use templates::TemplateMenu;
use xpress::*;
use cache::{TagAidsLock, TagsCache, AidsCache};

use std::fmt::Display;
use std::{env, str, thread};
use std::fs::{self, File, DirEntry};
use std::io::prelude::*;
use std::io::{self, Cursor, Read};
use std::path::{Path, PathBuf};
use std::time::{self, Instant, Duration};
use std::prelude::*;
use std::ffi::OsStr;
use std::collections::HashMap;
use std::sync::{Mutex, Arc, RwLock};
use std::sync::atomic::{AtomicUsize, Ordering};
use rocket;
use rocket::http::Status;
use rocket::State;
use rocket_contrib::Template;
use rocket::response::{self, Response, Responder};
use rocket::request::{FromRequest, Request};
use rocket::Outcome;
use rocket::Outcome::Success;
use rocket::response::NamedFile;
use rocket::http::{ContentType, Header, HeaderMap};

use comrak::{markdown_to_html, ComrakOptions};
use twoway;
use brotli;
use libflate::gzip;
use libflate::deflate;
use titlecase::*;
use htmlescape::*;


use ::serde::{Deserialize, Serialize};
use serde_json::{Value, Error};



pub fn destruct_context(ctx: ContentContext) -> (HashMap<String, PageContext>, usize) {
    let reader = ctx.pages.read().unwrap().clone();
    let size = ctx.size.load(Ordering::SeqCst);
    (reader, size)
}

pub fn destruct_cache(cache: ContentCacheLock) -> (HashMap<String, ContentCached>, usize) {
    let reader = cache.pages.read().unwrap().clone();
    let size = cache.size.load(Ordering::SeqCst);
    (reader, size)
}

pub fn destruct_multi(multi: TagAidsLock) -> (TagsCache, AidsCache) {
    (
     multi.tags_lock.into_inner()/*.expect("Failed to unwrap() tags cache for destruct_multi()")*/, 
     multi.aids_lock.into_inner()/*.expect("Failed to unwrap() aids cache for destruct_multi()")*/
     )
}

pub const SEPARATOR: &[u8] = b"
-----";


// How to load all the pages and get the contents of the Templates on app start?
//   it requires a Request either through a FromRequest or a Responder
//   - maybe pass the PageContext and other info to a Responder
//      Responder:
//          encoding
//          &ContentCacheLock (don't need &mut as the AtomicUsize and RwLock have interior mutability)
//          
//          
//          
//      maybe add a Template in the ContentContext because the Template can be used without a Responder directly
//      then use the cache structure to store the bytes and compressed bytes generated by the respond_to
//      only store the bytes or compressed versions when actually used
//          or maybe: only generate a ContentCached when used but generate all compressed versions at same time
//      
//      
//      

pub struct ContentContext {
    pub pages: RwLock<HashMap<String, PageContext>>,
    pub size: AtomicUsize,
}

pub struct ContentCacheLock {
    pub pages: RwLock<HashMap<String, ContentCached>>,
    pub size: AtomicUsize,
}

pub struct ContentRequest {
    pub encoding: AcceptCompression,
    pub route: String,
    pub start: GenTimer,
}

/// The cached contents of a fully rendered page.
/// Includes all versions of the pages for all compression methods.
#[derive(Debug, Clone)]
pub struct ContentCached {
    pub page: Vec<u8>,
    pub gzip: Vec<u8>,
    pub br: Vec<u8>,
    pub deflate: Vec<u8>,
    pub size: usize,
}

/// The context passed to the handlebars templates for the Page
#[derive(Debug, Clone, Serialize)]
pub struct PageContext {
    pub uri: String,
    pub title: String,
    pub body: String,
    pub template: String,
    pub js: Option<String>,
    pub description: Option<String>,
    pub gentime: String,
    pub base_url: String,
    pub admin: bool,
    pub user: bool,
    pub menu: Option<Vec<TemplateMenu>>,
    pub menu_dropdown: Option<Vec<TemplateMenu>>,
    pub dropdown: String,
    pub markdown: bool,
    pub extension: Option<String>,
    pub filename: Option<String>,
    pub downloadable: bool,
    pub disable_toc: bool,
}

/// Used to retrieve html and metadata from the page
pub struct PageFormat {
    yaml: Vec<u8>,
    html: Vec<u8>,
}

/// Used for the yaml deserialization method
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageInfo {
    pub uri: String,
    pub title: String,
    pub template: String,
    #[serde(default)]
    pub markdown: bool,
    #[serde(default)]
    pub js: Option<String>,
    #[serde(default)]
    pub description: Option<String>,
}







impl ContentContext {
    pub fn load(dir: &str) -> ContentContext {
        let dir_iter = fs::read_dir(dir);
        if let Ok(dir) = dir_iter {
            let mut size = 0;
            let mut pages: HashMap<String, PageContext> = HashMap::new();
            
            for file_rst in dir {
                if let Ok(file) = file_rst {
                    let path = file.path();
                    let name = file.file_name().to_string_lossy().into_owned();
                    if let Ok(file_type) = file.file_type() {
                        if !file_type.is_file() {
                            continue;
                        }
                    } else {
                        // if no file type can be found skip the file
                        continue;
                    }
                    
                    let ext = if let Some(ext_os) = path.extension() {
                        ext_os.to_string_lossy().into_owned().to_lowercase()
                    } else { "unknown".to_owned() };
                    
                    if ext == "bak" || ext == "old" { continue; }
                    
                    let load_rst = match ext.as_ref() {
                        "html" | "htm" | "xhtml" => { PageContext::load_plain(&path, name) },
                        "md" | "page" | "meta" | "metadata" => {
                            let stem = if let Some(stem_os) = path.file_stem() {
                                stem_os.to_string_lossy().into_owned()
                            } else { name };
                            PageContext::load_metadata(&path, stem)
                        },
                        "code" => {
                            // PageContext
                            let subtext: Option<String> = if let Some(s) = path.file_stem() {
                                let subname = s.to_string_lossy().into_owned();
                                if let Some(sub) = subname.rfind('.') {
                                    let ss = &subname[sub..];
                                    Some(ss.to_owned())
                                } else { None }
                            } else { None };
                            
                            let subext: Option<String> = None;
                            let stem = if let Some(stem_os) = path.file_stem() {
                                stem_os.to_string_lossy().into_owned()
                            } else { name };
                            
                            PageContext::load_code_metadata(&path, stem, subext)
                        }
                        // If no extension assume it is a markdown file
                        //   or it could also be viewed as code without syntax highlighting
                        "" => { PageContext::load_metadata(&path, name) },
                        "rs" => { PageContext::load_code(&path, name, "rust") },
                        "h" => { PageContext::load_code(&path, name, "cpp") },
                        "js" => { PageContext::load_code(&path, name, "javascript") },
                        "md" | "markdown" | "mdown" => { PageContext::load_code(&path, name, "markdown") },
                        "py" | "pyw" => { PageContext::load_code(&path, name, "python") },
                        "rb" => { PageContext::load_code(&path, name, "ruby") },
                        "bash" => { PageContext::load_code(&path, name, "bash") },
                        "sh" => { PageContext::load_code(&path, name, "shell") },
                        // docker is a valid highlightjs alias
                        // "docker" => { PageContext::load_code(&path, name, "dockerfile") },
                        "ahk" => { PageContext::load_code(&path, name, "autohotkey") },
                        "au3" => { PageContext::load_code(&path, name, "autoit") },
                        "coffee" => { PageContext::load_code(&path, name, "coffeescript") },
                        "ts" | "tsx" => { PageContext::load_code(&path, name, "typescript") },
                        "hbs" => { PageContext::load_code(&path, name, "handlebars") },
                        "log" => { PageContext::load_code(&path, name, "accesslog") },
                        // bat is a valid highlightjs alias
                        // "bat" => { PageContext::load_code(&path, name, "dos") },
                        "ps1" => { PageContext::load_code(&path, name, "powershell") },
                        "tmtheme" => { PageContext::load_code(&path, name, "plist") },
                        "unknown" => { PageContext::load_code(&path, name, "") },
                        _ => {
                            PageContext::load_code(&path, name, &ext)
                        },
                        
                    };
                    
                    if let Ok(ctx) = load_rst {
                        size += ctx.body.len();
                        println!("Loading file `{}` with uri `{}` using '.{}' extension", path.display(), &ctx.uri, &ext);
                        pages.insert(ctx.uri.clone(), ctx);
                    } else if let Err(err) = load_rst {
                        println!("Error loading {}: {}", path.display(), err);
                    } else {
                        println!("Unkown error loading {}", path.display());
                    }
                }
            }
            ContentContext {
                pages: RwLock::new(pages),
                size: AtomicUsize::new(size),
            }
            
        } else {
            ContentContext {
                pages: RwLock::new(HashMap::new()),
                size: AtomicUsize::new(0),
            }
        }
        
    }
}







impl ContentCacheLock {
    // Must start with an empty cache and fill it in as the pages are requested
    //   this is because the data inside a Template is hard to get to and 
    //   in this case uses a Responder to extract the contents
    pub fn new() -> ContentCacheLock {
        ContentCacheLock {
            pages: RwLock::new( HashMap::new() ),
            size: AtomicUsize::new( 0 ),
        }
    }
    
    /*
    // Note: this is a work in progress
    //         the rocket instance needs to be passed into the Client::new()
    //         but also needs to be in main, and can't use a mutable reference :(
    // Iterate through the pages directory and request the page (/content/<page>)
    pub fn cache(rocket: rocket::Rocket, dir: &str) {
        use rocket::local::Client;
        
        // let client = Client::new(rocket::ignite()).expect("valid rocket");
        // let req = client.post("/content/").dispatch();
        
        let client_rst = Client::new(rocket);
        if let Ok(client) = client_rst {
            let dir_iter = fs::read_dir(dir);
            if let Ok(dir) = dir_iter {
                for file_rst in dir {
                    if let Ok(file) = file_rst {
                        // let name = file.file_name().to_string_lossy().into_owned();
                        let name_path = file.path();
                        let name_opt = name_path.file_stem();
                        if let Some(name_os) = name_opt {
                            let name = name_os.to_string_lossy().into_owned();
                            
                            let page = format!("/content/{}", &name);
                            client.get(page).dispatch();
                        }
                    }
                }
            }
        }
        
    }*/
    
}

pub fn titlize(name: &str) -> String {
    let title_new = name.to_owned()
        .replace("-", " ")
        .replace("_", " ")
        ;
    titlecase(&title_new)
}


impl PageContext {
    pub fn load_code_metadata(path: &Path, name: String, subext: Option<String>) -> Result<Self, String> {
        if let Some(file) = PageFormat::get_file(path) {
            if let Some(parts) = PageFormat::get_parts(&file) {
                if let Some(mut meta) = parts.parse_metadata() {
                    if &meta.template ==  DEFAULT_PAGE_TEMPLATE {
                        meta.template = "page-code-template".to_owned();
                    }
                    meta.extension = subext;
                    Ok(meta)
                } else {
                    let title = titlize(&name);
                    let body = String::from_utf8_lossy(&file).into_owned().replace("{{base_url}}", BLOG_URL);
                    Ok(
                        PageContext {
                            uri: name.clone(),
                            title: title,
                            body: markdown_to_html(&body, &COMRAK_OPTIONS),
                            template: "page-code-template".to_owned(),
                            js: None,
                            description: None,
                            gentime: String::new(),
                            base_url: BLOG_URL.to_owned(),
                            admin: false,
                            user: false,
                            menu: DEFAULT_PAGE_MENU.clone(),
                            menu_dropdown: DEFAULT_PAGE_DROPDOWN.clone(),
                            dropdown: String::new(),
                            markdown: true,
                            extension: subext,
                            filename: Some(name),
                            downloadable: true,
                            disable_toc: false,
                        }
                    )
                }
            } else {
                let title = titlize(&name);
                let body = String::from_utf8_lossy(&file).into_owned().replace("{{base_url}}", BLOG_URL);
                Ok(
                    PageContext {
                        uri: name.clone(),
                        title: title,
                        body: markdown_to_html(&body, &COMRAK_OPTIONS),
                        template: "page-code-template".to_owned(),
                        js: None,
                        description: None,
                        gentime: String::new(),
                        base_url: BLOG_URL.to_owned(),
                        admin: false,
                        user: false,
                        menu: DEFAULT_PAGE_MENU.clone(),
                        menu_dropdown: DEFAULT_PAGE_DROPDOWN.clone(),
                        dropdown: String::new(),
                        markdown: false,
                        extension: subext,
                        filename: Some(name),
                        downloadable: true,
                        disable_toc: false,
                    }
                )
            }
        } else {
            Err(format!("Could not load contents of {}", path.display()))
        }
    }
    pub fn load_code(path: &Path, name: String, ext: &str) -> Result<PageContext, String> {
        if let Some(file) = PageFormat::get_file(path) {
            let title = titlize(&name);
            
            let body = encode_minimal(&String::from_utf8_lossy(&file))
                       .replace("{{base_url}}", BLOG_URL);
            Ok(
                PageContext {
                    uri: name.clone(),
                    title: title,
                    body: body,
                    template: "page-code-template".to_owned(),
                    js: None,
                    description: Some(ext.to_owned()),
                    gentime: String::new(),
                    base_url: BLOG_URL.to_owned(),
                    admin: false,
                    user: false,
                    menu: DEFAULT_PAGE_MENU.clone(),
                    menu_dropdown: DEFAULT_PAGE_DROPDOWN.clone(),
                    dropdown: String::new(),
                    markdown: false,
                    extension: Some(ext.to_owned()),
                    filename: Some(name),
                    downloadable: true,
                    disable_toc: false,
                }
            )
        } else {
            Err( format!("Could not load file for {}", path.display()) )
        }
    }
    pub fn load_plain(path: &Path, name: String) -> Result<Self, String> {
        if let Some(file) = PageFormat::get_file(path) {
            let title = titlize(&name);
            
            let body = String::from_utf8_lossy(&file).into_owned().replace("{{base_url}}", BLOG_URL);
            
            Ok(
                PageContext {
                    uri: name.clone(),
                    title: title,
                    body: body,
                    template: "page-blank-template".to_owned(),
                    js: None,
                    description: None,
                    gentime: String::new(),
                    base_url: BLOG_URL.to_owned(),
                    admin: false,
                    user: false,
                    menu: DEFAULT_PAGE_MENU.clone(),
                    menu_dropdown: DEFAULT_PAGE_DROPDOWN.clone(),
                    dropdown: String::new(),
                    markdown: false,
                    extension: None,
                    filename: Some(name),
                    downloadable: true,
                    disable_toc: false,
                }
            )
        } else {
            Err(format!("Could not load contents of {}", path.display()))
        }
    }
    pub fn load_metadata(path: &Path, name: String) -> Result<Self, String> {
        if let Some(file) = PageFormat::get_file(path) {
            if let Some(parts) = PageFormat::get_parts(&file) {
                
                // Thought about using Option.ok_or_else() but it
                // is nicer to be able to still load the file even
                // if the metadata can't be parsed
                // parts.parse_metadata().ok_or_else(|| format!())
                
                if let Some(meta) = parts.parse_metadata() {
                    Ok(meta)
                } else {
                    let title = titlize(&name);
                    let body = String::from_utf8_lossy(&file).into_owned().replace("{{base_url}}", BLOG_URL);
                    Ok(
                        PageContext {
                            uri: name.clone(),
                            title: title,
                            body: markdown_to_html(&body, &COMRAK_OPTIONS),
                            template: "page-template".to_owned(),
                            js: None,
                            description: None,
                            gentime: String::new(),
                            base_url: BLOG_URL.to_owned(),
                            admin: false,
                            user: false,
                            menu: DEFAULT_PAGE_MENU.clone(),
                            menu_dropdown: DEFAULT_PAGE_DROPDOWN.clone(),
                            dropdown: String::new(),
                            markdown: true,
                            extension: None,
                            filename: Some(name),
                            downloadable: false,
                            disable_toc: false,
                        }
                    )
                }
            } else {
                let title = titlize(&name);
                let body = String::from_utf8_lossy(&file).into_owned().replace("{{base_url}}", BLOG_URL);
                Ok(
                    PageContext {
                        uri: name.clone(),
                        title: title,
                        body: markdown_to_html(&body, &COMRAK_OPTIONS),
                        template: "page-template".to_owned(),
                        js: None,
                        description: None,
                        gentime: String::new(),
                        base_url: BLOG_URL.to_owned(),
                        admin: false,
                        user: false,
                        menu: DEFAULT_PAGE_MENU.clone(),
                        menu_dropdown: DEFAULT_PAGE_DROPDOWN.clone(),
                        dropdown: String::new(),
                        markdown: true,
                        extension: None,
                        filename: Some(name),
                        downloadable: true,
                        disable_toc: false,
                    }
                )
            }
        } else {
            Err(format!("Could not load contents of {}", path.display()))
        }
    }
}






impl PageFormat {
    /// Reads a file into a byte vector
    pub fn get_file(path: &Path) -> Option<Vec<u8>> {
        if let Ok(mut file) = File::open(path) {
            if let Ok(metadata) = file.metadata() {
                let mut buffer: Vec<u8> = Vec::with_capacity((metadata.len() + 50) as usize);
                file.read_to_end(&mut buffer);
                Some(buffer)
            } else {
                None
            }
        } else {
            None
        }
    }
    
    /// Take a byte vector and convert it to metadata and html parts.
    pub fn get_parts(buffer: &[u8]) -> Option<Self> {
        let sep_pos = twoway::find_bytes(buffer, SEPARATOR);
        
        if let Some(pos) = sep_pos {
            // println!("DEBUG: found separator at index: {}", pos);
            let start_at = pos + (SEPARATOR.len());
            
            // println!("DEBUG: starting search for html at index: {}", start_at);
            
            
            // the b" at the end is intentional and specifies a newline
            let html_start = twoway::find_bytes(&buffer[start_at..], b"
");
            if let Some(mut html_pos) = html_start {
                html_pos += start_at+1;
                
                // println!("DEBUG: found html at index: {}", html_pos);
                
                let parts = PageFormat {
                    yaml: buffer[..pos].to_vec(),
                    html: buffer[html_pos..].to_vec(),
                };
                
                Some(parts)
            } else {
                None
            }
        } else {
            None
        }
    }
    
    /// Deprecated. 
    /// Deserializes a yaml byte vector into a PageContext
    pub fn parse_yaml(self) -> Option<PageContext> {
        let yaml_des: Result<PageInfo, _> = ::serde_yaml::from_slice(&self.yaml);
        
        if let Ok(info) = yaml_des {
            Some(info.to_context(self.html))
        } else if let Err(err) = yaml_des {
            println!("Error occurred converting yaml to PageContext:\n{}", err);
            None
        } else {
            None
        }
    }
    
    pub fn parse_metadata(self) -> Option<PageContext> {
        let mut pos = 0usize;
        let colon = b":";
        let newline = b"\n";
        
        let mut uri = String::new();
        let mut title = String::new();
        let mut template = DEFAULT_PAGE_TEMPLATE.to_owned();
        let mut js = None;
        let mut description = None;
        let mut admin = false;
        let mut user = false;
        let mut menu: Option<Vec<TemplateMenu>> = DEFAULT_PAGE_MENU.clone();
        let mut menu_dropdown: Option<Vec<TemplateMenu>> = DEFAULT_PAGE_DROPDOWN.clone();
        let mut dropdown: String = String::new();
        let mut markdown = true;
        let mut downloadable = true;
        let mut disable_toc = false;
        let mut extension: Option<String> = None;
        let mut filename: Option<String> = None;
        
        while let Some(end) = next_field(&self.yaml, pos) {
            // let end = e + pos;
            // println!("Searching for field separator @ {}..{}", pos, end);
            
            // field separator
            if let Some(f) = twoway::find_bytes(&self.yaml[pos..end], colon) {
                let fs = f + pos;
                // println!("Found field separator @ {fs}.  {pos} .. {fs}: .. {end}", fs=fs, pos=pos, end=end);
                
                let k = String::from_utf8_lossy(&self.yaml[pos..fs]).to_lowercase();
                // let k = String::from_utf8_lossy(&self.yaml[pos..fs]).into_owned();
                // let key = k.trim().to_lowercase();
                let key = k.trim();
                // println!("Found key: `{}`, val: `{}`", key, String::from_utf8_lossy(&self.yaml[fs+1..end]));
                
                let val_range: &[u8] = &self.yaml[fs+1..end];
                
                match key {
                    "uri" | "url" | "address" => { uri = String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned(); },
                    "title" => { title = String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned(); },
                    "template" | "layout" | "theme" => { template = String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned(); },
                    "js" | "javascript" | "script" => { js = Some(String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned()); },
                    "description" | "desc" => { description = Some(String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned().replace("{{base_url}}", BLOG_URL)); },
                    "admin" | "administrator" => { admin = bytes_are_true(&self.yaml[fs+1..end], false); },
                    "user" | "logged_in" | "logged-in" => { user = bytes_are_true(&self.yaml[fs+1..end], false); },
                    "menu" | "menu_basic" | "menu-basic" => { menu = json_menu(&self.yaml[fs+1..end]); },
                    "menu-dropdown" | "dropdown-menu" | "menu_dropdown" | "dropdown_menu" => { menu_dropdown = json_menu(&self.yaml[fs+1..end]); },
                    "dropdown" | "dropdown_name" | "menu_name" | "dropdown-name" | "menu-name" => { dropdown = String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned(); },
                    "markdown" | "md" => { markdown = bytes_are_true(val_range, false) },
                    "downloadable" | "download" | "source" => { downloadable = bytes_are_true(&self.yaml[fs+1..end], false); },
                    "disable_toc" | "disable-toc" | "no-table-of-contents" | "no_table_of_contents" => { disable_toc = bytes_are_true(&self.yaml[fs+1..end], false); },
                    "ext" | "extension" | "language" | "lang" => { extension = Some(String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned()) },
                    "file" | "filename" => { filename = Some(String::from_utf8_lossy(&self.yaml[fs+1..end]).into_owned().trim().to_owned()) },
                    _ => {},
                }
                
            } else {
                // println!("No field separator found.");
                // break;
            }
            pos = end+1;
            if pos >= self.yaml.len() {
                // println!("Reached end, breaking...");
                break;
            }
        }
        
        
        let mut temp_ok = false;
        for temp in PAGE_TEMPLATES {
            if &template == temp {
                temp_ok = true;
            }
        }
        
        if &uri != ""
        && &title != "" {
            Some(PageContext {
                uri,
                title: title,
                template: if temp_ok && &template != "" { template } else { DEFAULT_PAGE_TEMPLATE.to_owned() },
                js,
                description,
                body: {
                    let body = String::from_utf8_lossy(&self.html).into_owned().replace("{{base_url}}", BLOG_URL);
                    if markdown {
                        // let cr_options = ComrakOptions { ext_header_ids: Some("section-".to_string()), .. COMRAK_OPTIONS };
                         let html: String = markdown_to_html(&body, &COMRAK_OPTIONS);
                         html
                    } else {
                        body
                    }
                },
                gentime: String::new(),
                base_url: BLOG_URL.to_owned(),
                admin,
                user,
                menu,
                menu_dropdown,
                dropdown,
                markdown,
                extension,
                filename,
                downloadable,
                disable_toc,
            })
        } else {
            // println!("Required fields missing for PageContext:\nuri: `{}`\ntitle: `{}`", &uri, &title);
            None
        }
    }
}

/// Takes a byte vector and converts to a TemplateMenu vector.
pub fn json_menu(json: &[u8]) -> Option<Vec<TemplateMenu>> {
    let des: Result<Vec<TemplateMenu>, _> = ::serde_json::from_slice(json);
    
    if let Ok(d) = des {
        Some(d)
    } else if let Err(e) = des {
        println!("Error deserializing the json menu:\n{:?}\n in: `{}`", e, String::from_utf8_lossy(json).into_owned());
        None
    } else {
        println!("Json menu error :(");
        None
    }
}

// Safely check to see if a slice of bytes matches a specific value.
// This will check to make sure the byte slice is not smaller than the
// value, which would panic.
pub fn safe_check_bytes(bytes: &[u8], start: usize, value: &[u8]) -> Option<()> {
    if start+value.len() <= bytes.len() {
        if &bytes[start..(start+value.len())] == value {
            Some( () )
        } else {
            None
        }
    } else {
        None
    }
}

pub fn bytes_are_true(bytes: &[u8], default: bool) -> bool {
    let mut pos: usize = 0;
    for b in bytes.iter() {
        // look for first non-space (32 in ascii decimal)
        if *b != 32u8 {
            break;
        }
        pos += 1;
    }
    
    if default == false {
        if safe_check_bytes(&bytes, pos, b"true").is_some()
        || safe_check_bytes(&bytes, pos, b"True").is_some()
        || safe_check_bytes(&bytes, pos, b"yes").is_some()
        || safe_check_bytes(&bytes, pos, b"Yes").is_some()
        || safe_check_bytes(&bytes, pos, b"1").is_some()
        || safe_check_bytes(&bytes, pos, b"on").is_some()
        || safe_check_bytes(&bytes, pos, b"On").is_some()
        || safe_check_bytes(&bytes, pos, b"Enabled").is_some()
        || safe_check_bytes(&bytes, pos, b"enabled").is_some()
        || safe_check_bytes(&bytes, pos, b"Enable").is_some()
        || safe_check_bytes(&bytes, pos, b"enable").is_some() {
            true
        } else {
            false
        }
    } else {
        if safe_check_bytes(&bytes, pos, b"false").is_some()
        || safe_check_bytes(&bytes, pos, b"False").is_some()
        || safe_check_bytes(&bytes, pos, b"no").is_some()
        || safe_check_bytes(&bytes, pos, b"No").is_some()
        || safe_check_bytes(&bytes, pos, b"0").is_some()
        || safe_check_bytes(&bytes, pos, b"off").is_some()
        || safe_check_bytes(&bytes, pos, b"off").is_some()
        || safe_check_bytes(&bytes, pos, b"Disabled").is_some()
        || safe_check_bytes(&bytes, pos, b"disabled").is_some()
        || safe_check_bytes(&bytes, pos, b"Disable").is_some()
        || safe_check_bytes(&bytes, pos, b"disabled").is_some() {
            false
        } else {
            true
        }
    }
    
    // if default == false {
    //     if &bytes[pos..pos+4] == b"true" 
    //     || &bytes[pos..pos+3] == b"yes" 
    //     || &bytes[pos..pos+3] == b"Yes" 
    //     || &bytes[pos..pos+4] == b"True" 
    //     || &bytes[pos..pos+1] == b"1" 
    //     || &bytes[pos..pos+2] == b"on" 
    //     || &bytes[pos..pos+2] == b"On" {
    //         true
    //     } else {
    //         false
    //     }
    // } else {
    //     if &bytes[pos..pos+5] == b"false" 
    //     || &bytes[pos..pos+2] == b"no" 
    //     || &bytes[pos..pos+2] == b"No" 
    //     || &bytes[pos..pos+5] == b"False" 
    //     || &bytes[pos..pos+1] == b"0" 
    //     || &bytes[pos..pos+3] == b"off" 
    //     || &bytes[pos..pos+3] == b"Off" {
    //         false
    //     } else {
    //         true
    //     }
    // }
}

/// Find next newline character until the end is reached.
/// The final line of data will not contain a linebreak but 
/// must still be processed.
pub fn next_field(yaml: &Vec<u8>, pos: usize) -> Option<usize> {
    let newline = b"
";
    if let Some(end) = twoway::find_bytes(&yaml[pos..yaml.len()], newline) {
        Some(end + pos)
    } else {
        if pos < yaml.len() {
            Some(yaml.len())
        } else {
            None
        }
    }
}

impl PageInfo {
    /// Takes metadata and body contents and creates a context for the Template.
    pub fn to_context(self, html: Vec<u8>) -> PageContext {
        let context = PageContext {
            uri: self.uri,
            title: self.title,
            body: {
                let body = String::from_utf8_lossy(&html).into_owned();
                if self.markdown {
                    let cr_options = ComrakOptions { ext_header_ids: Some("section-".to_string()), .. COMRAK_OPTIONS };
                     let html: String = markdown_to_html(&body, &cr_options);
                     html
                } else {
                    body
                }
            },
            template: self.template,
            js: self.js,
            description: self.description,
            admin: false,           // Default values, this is only used for the yaml deserialization and not used with any actual menus
            user: false,            // Default values, this is only used for the yaml deserialization and not used with any actual menus
            menu: None,             // Default values, this is only used for the yaml deserialization and not used with any actual menus
            menu_dropdown: None,    // Default values, this is only used for the yaml deserialization and not used with any actual menus
            gentime: String::with_capacity(200),
            base_url: String::with_capacity(200),
            dropdown: String::new(),
            markdown: false,
            extension: None,
            filename: None,
            downloadable: true,
            disable_toc: false,
        };
        context
    }
}







impl<'a> Responder<'a> for ContentRequest 
{
    fn respond_to(self, req: &Request) -> response::Result<'a> 
    {
        // get body contents then build an Express instance
        
        // look for the uri entry in self.cache
        // if exists use self.cache.pages.read() to read from the RwLock in the ContentCache
        //   and pull the compression method/original (specified by encoding.preferred()) from the cache
        // if not then create the new cache entry
        
        // DEBUG PRINT - println!("Responding to static page: {}", &self.route);
        
        let context_state = req.guard::<State<ContentContext>>().unwrap();
        let ctx_pages_rst = context_state.pages.read();
        let ctx_pages;
        if let Ok(ctxpages) = ctx_pages_rst {
            ctx_pages = ctxpages;
        } else {
            return Err(Status::InternalServerError);
        }
        let cache_state = req.guard::<State<ContentCacheLock>>().unwrap();
        /*  1. Check for existence of uri in cache map (the content page route already checks for existence of page context for the given uri)
            2. If uri is not in cache map look for it in the context map (has to be in there but double check - don't use unwrap())
                   Add combined size of ContentCached fields to ContentCacheLock's size field
                       Use a checked add so the size never overflows, it just reaches a max value
        */
        
        // ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----
        // To improve performance: instead of cloning the byte vector:
        //   instead of body_bytes make the match'd contents a reference
        //   make a String::new() that is converted .into() an Express instance
        //   then do xresp.streamed_body( Cursor::new(body_bytes_reference) )
        // ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----
        
        {
            let cache_map_lock = cache_state.pages.read();
            let cache_map;
            if let Ok(cm) = cache_map_lock {
                cache_map = cm;
            } else {
                return Err(Status::InternalServerError)
            }
            let cache_uri_opt = cache_map.get(&self.route);
            
            if let Some(cache_uri) = cache_uri_opt {
                // DEBUG PRINT - println!("Page exists in cache");
                
                let mut body_bytes = match self.encoding.preferred() {
                    Uncompressed => { cache_uri.page.clone() },
                    Brotli => { cache_uri.br.clone() },
                    Gzip => { cache_uri.gzip.clone() },
                    Deflate => { cache_uri.deflate.clone() },
                };
                let express: Express = body_bytes.into();
                
                let end = self.start.0.elapsed();
                println!("Content processed in {}.{:09} seconds", end.as_secs(), end.subsec_nanos());
                
                return express.respond_to(req)
            }
        }
            // DEBUG PRINT - println!("Page not found in cache, generating cache for page");
            
            if let Some(ctx) = ctx_pages.get(&self.route) {
                
                // DEBUG PRINT - println!("Retrieved context");
                
                let template: Template = Template::render( (&ctx.template).to_owned(), &ctx );
                let express: Express = template.into();
                let mut resp = express.respond_to(req).unwrap_or_default();
                let mut output_contents: Vec<u8> = Vec::new();
                let mut new_cache = ContentCached {
                    page: Vec::new(),
                    gzip: Vec::new(),
                    br: Vec::new(),
                    deflate: Vec::new(),
                    size: 0usize,
                };
                if let Some(body) = resp.body_bytes() {
                    output_contents = body;
                    
                    // DEBUG PRINT - print!("Generating compressed versions.. ");
                    
                    let gzip: Vec<u8>;
                    {
                        let mut buffer = Vec::with_capacity(output_contents.len() + 200);
                        let mut gzip_encoder = gzip::Encoder::new(buffer).unwrap();
                        gzip_encoder.write_all(&output_contents).expect("Compresing gzip failed"); // .expect("Gzip compression failed.");
                        gzip = gzip_encoder.finish().into_result().unwrap_or(Vec::new());
                    }
                    
                    let br: Vec<u8>;
                    {
                        let length = output_contents.len()+200;
                        let mut buffer = Vec::with_capacity(length);
                        let mut compressor = ::brotli::CompressorReader::new(Cursor::new(&output_contents), length, 9, 22);
                        let _ = compressor.read_to_end(&mut buffer);
                        br = buffer;
                    }
                    
                    let deflate: Vec<u8>;
                    {
                        let mut buffer = Vec::with_capacity(output_contents.len()+200);
                        let mut encoder = deflate::Encoder::new(buffer);
                        encoder.write_all(&output_contents); //.expect("Deflate compression failed.");
                        deflate = encoder.finish().into_result().unwrap_or(Vec::new());
                        
                    }
                    
                    // DEBUG PRINT - print!(" Finished! Compressed versions of page have been generated.\n");
                    
                    // Find the best compression algorithm for the client
                    let mut supported = 0u8;
                    let headers = req.headers();
                    if let Some(encoding) = headers.get("Accept-Encoding").next() {
                        if encoding.contains("gzip") { supported |= ::accept::GZIP; }
                        if encoding.contains("deflate") { supported |= ::accept::DEFLATE; }
                        if encoding.contains("br") { supported |= ::accept::BROTLI; }
                    }
                    let accepted = AcceptCompression::new(supported);
                    let compression = accepted.preferred();
                    // Set the correct version of the contents based on best supported compression algorithm
                    let bytes = match compression {
                        CompressionEncoding::Brotli => { 
                            resp.set_raw_header("Content-Encoding", "br");
                            br.clone() 
                        },
                        CompressionEncoding::Gzip => { 
                            resp.set_raw_header("Content-Encoding", "gzip");
                            gzip.clone() 
                        },
                        CompressionEncoding::Deflate => { 
                            resp.set_raw_header("Content-Encoding", "deflate");
                            deflate.clone() 
                        },
                        CompressionEncoding::Uncompressed => output_contents.clone(),
                    };
                    
                    // DEBUG PRINT - print!("Setting body content..  ");
                    
                    resp.set_streamed_body(
                        Cursor::new( bytes )
                    );
                    
                    // DEBUG PRINT - print!("Finished setting body content.\n");
                    
                    let total_size = output_contents.len() + gzip.len() + br.len() + deflate.len();
                    new_cache = ContentCached {
                        page: output_contents,
                        gzip,
                        br,
                        deflate,
                        size: total_size,
                    };
                    
                    // DEBUG PRINT - println!("Created cache object");
                    
                    println!("Attempting to write cache object to hashmap");
                    // remember to put the body from body_bytes back into the resp, body_bytes() consumes the bytes
                    // insert new_cache into cache map, make sure to unlock it for write access
                    {
                        // let mut wcache = cache_state.pages.write().unwrap();
                        let mut wcache = cache_state.pages.write().unwrap();
                        wcache.insert(self.route.clone(), new_cache.clone());
                        
                    }
                    
                    // DEBUG PRINT - println!("Successfully inserted cache object");
                    
                    // DEBUG PRINT - println!("Responder finished, returning response..");
                    
                    let end = self.start.0.elapsed();
                    println!("Content processed in {}.{:09} seconds", end.as_secs(), end.subsec_nanos());
                
                    Ok( resp )
                    
                } else {
                    // fail - uri not found in context map
                    println!("Responder failed to extract response body");
                    Err(Status::ImATeapot)
                }
                
                
            } else {
                println!("Responder failed to find uri `{}` in the context map.", &self.route);
                Err(Status::NotFound)
            }
        // }
    }
}

















